<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ben Mask</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Ben Mask</description>
    <generator>Hugo -- 0.135.0</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 Jan 2025 20:49:46 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Visual Systems Design: URL Shortener</title>
      <link>http://localhost:1313/posts/08-url-shortener/</link>
      <pubDate>Mon, 13 Jan 2025 20:49:46 -0500</pubDate>
      <guid>http://localhost:1313/posts/08-url-shortener/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;I have been studying more systems desing more intentionally lately and this is the fruit of one evening of diagramming out a URL Shortner design. This post doesn&amp;rsquo;t explain much but a picture&amp;rsquo;s worth a thousand words!
&lt;br&gt;
&lt;br&gt;
&lt;img loading=&#34;lazy&#34; src=&#34;./images/url_shortener.svg#wide&#34; alt=&#34;URL Shortener&#34;  /&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>Distributed Concensus: Raft</title>
      <link>http://localhost:1313/posts/09-raft/</link>
      <pubDate>Sun, 12 Jan 2025 10:58:42 -0500</pubDate>
      <guid>http://localhost:1313/posts/09-raft/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;With the addition of a Proxmox server to my homelab I have been planning to scale out the control plane of my k3s cluster by virtualizing an additional two master nodes for a HA set up. I was aware that this would involve replicated state in my etcd backed control plane and that etcd itself relies on the Raft concensus algorithm. For this reason, I decided to take a deeper dive into the inner workings of Raft.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ZFS: A Primer</title>
      <link>http://localhost:1313/posts/07-zfs-primer/</link>
      <pubDate>Sun, 05 Jan 2025 21:20:26 -0500</pubDate>
      <guid>http://localhost:1313/posts/07-zfs-primer/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;Zettabit File System (ZFS) is a file system that is very popular in the Homelab community for it&amp;rsquo;s powerful capabilities as a file system and volume manager. It is designed to ensure data integrity and scalbility. While I am not an expert in ZFS, I hope to create guide here that outlines some of the fundamantal concepts of ZFS that I can return to over time.&lt;/p&gt;
&lt;p&gt;ZFS has a few key features that I will outline here:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dependency Injection In Go</title>
      <link>http://localhost:1313/posts/06-go-dependency-injection/</link>
      <pubDate>Sat, 07 Sep 2024 19:57:08 -0400</pubDate>
      <guid>http://localhost:1313/posts/06-go-dependency-injection/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;Dependency Injection (the &amp;lsquo;D&amp;rsquo; in SOLID design principles) is an important practice in good software architecture. When used well, it decouples a class&amp;rsquo;s dependency on a certain interface from any one particular implementation of that dependency. This means that any class which implements the common interface of the dependency can be injected into the class at runtime for easy configuration. This is especially helpful when it comes to creating stubs for mocking when writing unit tests.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Intro to K8s Autoscaling</title>
      <link>http://localhost:1313/posts/05-intro-to-k8s-autoscaling/</link>
      <pubDate>Fri, 06 Sep 2024 19:57:08 -0400</pubDate>
      <guid>http://localhost:1313/posts/05-intro-to-k8s-autoscaling/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;Autoscaling is a key technology that builds on the elasticity of distributed cloud computing. To understand autoscaling in the Kubernetes environment, it will be important to understand the basic enabling technologies: containerization and distributed computing. By leveraging hese two technologies, Kubernetes supports horizontal pod autoscaling (hpa) and cluster autoscaling. In this post I will dive into some brief background on Containerization and distributed computing (just enough to be dangerous) and then take a more focused look at the horizontal autoscaling functionality of Kubernetes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding CIDR Blocks and IPv4 Addressing</title>
      <link>http://localhost:1313/posts/04-understanding-ipv4-addressing/</link>
      <pubDate>Fri, 09 Aug 2024 20:01:16 -0400</pubDate>
      <guid>http://localhost:1313/posts/04-understanding-ipv4-addressing/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;The goal of this post will be to give an overview of IPv4 addresses. My aim is to do this incrementally by first covering the anatomy of an IPv4 address in its base 10 and binary representations. Second, I will look at CIDR block subnetting and subnet masks. Thirdly, I will append some helpful formulas for working with IP addresses.&lt;/p&gt;
&lt;h1 id=&#34;background--history&#34;&gt;Background &amp;amp; History&lt;/h1&gt;
&lt;p&gt;Before diving into the anatomy of IPv4 let&amp;rsquo;s turn back the page. In 1981, RFC 791 was published. This document outlined the &lt;em&gt;Internet Protocol&lt;/em&gt; and the IPv4 addressing scheme that would be used to uniquely identify and locate machines on the Internet.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Load Testing Applications with Locust</title>
      <link>http://localhost:1313/posts/03-locust-load-testing/</link>
      <pubDate>Mon, 22 Jul 2024 21:22:31 -0400</pubDate>
      <guid>http://localhost:1313/posts/03-locust-load-testing/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;I was recently tasked with configuring automated load tests to validate the health of a service under load and to identify bottlenecks and limits at which the service became overloaded. Up until this point, I had not worked first-hand with any load-testing frameworks. Although there are many great load testing tools out there like JMeter, K6s, and Locust, I decided to get started with Locust as it is a framework I had heard of before and is a pure Python framework (Python is the language I think in right now). To rewind, load testing frameworks allow engineers to programmatically produce stress on a system by simulating a large volume of incoming requests to that system. Requests can be, but are not limited to, HTTP calls. You can also load test with gRPC or IoT protocols like MQTT. Locust is an open-source Python-based load testing framework. With Locust, all user behaviour is defined in Python code and tests can be executed from a single machine or distributed across many machines.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Part 2: Building a Bare-metal Kubernetes Cluster on Raspberry Pis</title>
      <link>http://localhost:1313/posts/02-bare-metal-k3s-on-rpi-part-2/</link>
      <pubDate>Sun, 21 Jul 2024 20:30:55 -0400</pubDate>
      <guid>http://localhost:1313/posts/02-bare-metal-k3s-on-rpi-part-2/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;In part 1 of this post, I covered the basics of getting started building my Kubernetes cluster on Raspberry Pis. In particular, I laid out my goals and requirements, the build list, the network topology and setup, and the installation of K3s on each of the nodes. I recommend going back and checking out that post first if you haven&amp;rsquo;t already (&lt;a href=&#34;https://blog.fallow.app/posts/02-bare-metal-k3s-on-rpi-part-1/&#34;&gt;Part 1: Building a Bare-metal Kubernetes Cluster on Raspberry Pis&lt;/a&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Part 1: Building a Bare-metal Kubernetes Cluster on Raspberry Pis</title>
      <link>http://localhost:1313/posts/02-bare-metal-k3s-on-rpi-part-1/</link>
      <pubDate>Wed, 10 Jul 2024 20:29:01 -0400</pubDate>
      <guid>http://localhost:1313/posts/02-bare-metal-k3s-on-rpi-part-1/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;images/cluster.png&#34; alt=&#34;cluster&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;From the start of my career, I have been fascinated by Kubernetes. I love distributed systems and the rich history of how we have arrived where we are today with distributed computing. We live in the ongoing evolution of our communal vision for cloud computing. In the early years, the vision was to present a homogenous Unix-like interface for managing an underlying collection of servers such as BOINC. Now, we live in the world of many small virtualized unix environments distributed across servers and sharing compute.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Getting Started with Hugo &amp; GitHub Pages</title>
      <link>http://localhost:1313/posts/01-getting-started-w-hugo/</link>
      <pubDate>Fri, 05 Jul 2024 17:54:14 -0400</pubDate>
      <guid>http://localhost:1313/posts/01-getting-started-w-hugo/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;The goal of this post is to capture the steps required to get started with Hugo and GitHub Pages. Hugo is a Go-based static site generation tool. GitHub Pages is a feature of GitHub that allows anyone with a GitHub account to host a static site.&lt;/p&gt;
&lt;h1 id=&#34;part-1-setting-up-github-pages&#34;&gt;Part 1: Setting up GitHub Pages&lt;/h1&gt;
&lt;p&gt;In order to serve your site, you will need somewhere to host it. GitHub offers a free service called GitHub Pages that we will use for this purpose. GitHub Pages offers the free hosting of static website content. This means we will be able to build our Hugo site into a static site and then serve that via
GitHub Pages.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
