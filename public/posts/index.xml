<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Ben Mask</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Ben Mask</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 20 Dec 2025 12:44:43 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Discovering Steph Ango</title>
      <link>http://localhost:1313/posts/15-steph-ango/</link>
      <pubDate>Sat, 20 Dec 2025 12:44:43 -0500</pubDate>
      <guid>http://localhost:1313/posts/15-steph-ango/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;This week I discovered the writing and work of Steph Ango. Steph is the CEO of Obsidian, has a background in biology and industrial design, and has some really interesting ideas around design, consumption, and creativity that I&amp;rsquo;ve enjoyed diving into.&lt;/p&gt;
&lt;p&gt;He hosts a blog &lt;a href=&#34;https://stephango.com/&#34;&gt;here&lt;/a&gt; and the Dialectic podcast from Notion has a great long-form &lt;a href=&#34;https://open.spotify.com/episode/5RDXPYjvNWqK933eHQNhHP&#34;&gt;interview with Steph&lt;/a&gt; about how he views work, building teams, products, and more.&lt;/p&gt;
&lt;p&gt;What I really appreciated about Steph was his clear and concise communication around the values (in my own words now) of building with intentionality and not for markets, consumption of goods that don&amp;rsquo;t consume you, and stripping away unnecessary complexity. Below are some highlights from that interview along with some articles of his that I resonated with. Enjoy!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Immich: Up &amp; Running</title>
      <link>http://localhost:1313/posts/14-immich/</link>
      <pubDate>Sun, 14 Dec 2025 22:43:07 -0500</pubDate>
      <guid>http://localhost:1313/posts/14-immich/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;p&gt;I recently started hosting &lt;a href=&#34;https://github.com/immich-app&#34;&gt;Immich&lt;/a&gt; on my homelab. If you&amp;rsquo;re not familiar with Immich, it is a self-hosted Google Photos replacement.
If you want to learn more I highly reccomend giving a listen to &lt;a href=&#34;https://selfhosted.show/110?t=1198&#34;&gt;this podcast interview&lt;/a&gt; with the creator of Immich on the Self-Hosted podcast.&lt;/p&gt;
&lt;p&gt;The goal of this post is to cover how I set this up and some of the obstacles I faced in the process.&lt;/p&gt;
&lt;h1 id=&#34;immich-architecture-and-storage&#34;&gt;Immich Architecture and Storage&lt;/h1&gt;
&lt;p&gt;There wasn&amp;rsquo;t much to plan out before deploying Immich. The main pain point came with respect to getting Postgres running up on my cluster prior to deploying Immich which I&amp;rsquo;ll cover more below.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Index Condition Pushdown Optimization in MySQL</title>
      <link>http://localhost:1313/posts/13-mysql-icp/</link>
      <pubDate>Mon, 02 Jun 2025 21:56:17 -0400</pubDate>
      <guid>http://localhost:1313/posts/13-mysql-icp/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;Getting under the hood of database implementations is becoming an area of growing interest for me. Early in my career, I was always content with SQL as an interface to a datastore that &amp;ldquo;just works.&amp;rdquo; That is, until it doesn&amp;rsquo;t anymore. It&amp;rsquo;s at those points that I am now being pushed to understand why a particular database implementation has certain behavioral characteristics in different circumstances. Further, I have never crossed paths with a professional DBA and often feel like there&amp;rsquo;s a whole sphere of mystery for me here. As I plunge these depths for the first time, however, I find many of the same interesting aspects of design and layering that have made K8s of interest to me.&lt;/p&gt;</description>
    </item>
    <item>
      <title>An Introduction to Async Programming in Python</title>
      <link>http://localhost:1313/posts/12-python-async/</link>
      <pubDate>Sat, 03 May 2025 15:24:28 -0400</pubDate>
      <guid>http://localhost:1313/posts/12-python-async/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;In this post I want to capture some introductory notes to async programming in Python. I want to capture the motivation for async programming, some examples of how async implemented in Python via the high-level apis of Python&amp;rsquo;s stdlib async programming module: &lt;code&gt;asyncio&lt;/code&gt;, and finally I want to explore the mechanics of the event loop which enable async programming.&lt;/p&gt;
&lt;h1 id=&#34;motivation-the-problem-of-io-bound-programs&#34;&gt;Motivation: The Problem of IO Bound Programs&lt;/h1&gt;
&lt;p&gt;The goal of Python&amp;rsquo;s asyncio is module is improving the efficieny of IO bound programs. To understand what that means we need to understand the characteristics and the inefficiency of IO bound programs in the absennce of async programming apis.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Making my K8s Control Plane HA</title>
      <link>http://localhost:1313/posts/11-ha-k8s/</link>
      <pubDate>Sun, 23 Feb 2025 21:10:27 -0500</pubDate>
      <guid>http://localhost:1313/posts/11-ha-k8s/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;For a while the K8s cluster in my homelab has been in the precarious situation of only having a single master node. This has bitten me a couple of times when the master node (i.e the &amp;ldquo;server node&amp;rdquo; in k3s) has been snafu&amp;rsquo;ed.&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;./images/meme.png&#34; alt=&#34;meme&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;Now that I have compute available on my proxmox server, I want to take the time to virtualize two additional master nodes. Doing this will require understanding a few things at the outset:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tenets of Engineering</title>
      <link>http://localhost:1313/posts/10-tenets/</link>
      <pubDate>Thu, 06 Feb 2025 21:07:51 -0500</pubDate>
      <guid>http://localhost:1313/posts/10-tenets/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;I am getting to the stage of my career now where I have started picking up guiding principles that guide my socio-technical endeavors. I am sure I will continue to learn more and add them here or come back revise these with more wisdom and insight but what I want to start here is a collection of tenets. These tenets are not implementation details or design patterns but are more like paradigms for how we relate to problems, the natural systems that emerge from people thrown into teams, and more.&lt;/p&gt;</description>
    </item>
    <item>
      <title>TrueNAS Backups &amp; Restore with B2</title>
      <link>http://localhost:1313/posts/09-truenas-backups/</link>
      <pubDate>Thu, 23 Jan 2025 19:30:52 -0500</pubDate>
      <guid>http://localhost:1313/posts/09-truenas-backups/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;The goal of this post will be to capture the steps required for the backup and restore process of my TrueNAS server. Currenty, my TrueNAS server consists of two 4TB drives in a vdev with a RAID1 (Mirror) config. My goal is to back this up to Backblaze&amp;rsquo;s S3-compatible B2 storage and test recovery before migrating data out of my old 1TB SSD.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Once I have these backups in places the 3-2-1 rule will be satisfied:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Visual: URL Shortener</title>
      <link>http://localhost:1313/posts/08-url-shortener/</link>
      <pubDate>Mon, 13 Jan 2025 20:49:46 -0500</pubDate>
      <guid>http://localhost:1313/posts/08-url-shortener/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;I have been studying more systems desing more intentionally lately and this is the fruit of one evening of diagramming out a URL Shortner design. This post doesn&amp;rsquo;t explain much but a picture&amp;rsquo;s worth a thousand words!
&lt;br&gt;
&lt;br&gt;
&lt;img loading=&#34;lazy&#34; src=&#34;./images/url_shortener.svg#wide&#34; alt=&#34;URL Shortener&#34;  /&gt;
&lt;/p&gt;</description>
    </item>
    <item>
      <title>Distributed Concensus: Raft</title>
      <link>http://localhost:1313/posts/09-raft/</link>
      <pubDate>Sun, 12 Jan 2025 10:58:42 -0500</pubDate>
      <guid>http://localhost:1313/posts/09-raft/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;With the addition of a Proxmox server to my homelab I have been planning to scale out the control plane of my k3s cluster by virtualizing an additional two master nodes for a HA set up. I was aware that this would involve replicated state in my etcd backed control plane and that etcd itself relies on the Raft concensus algorithm. For this reason, I decided to take a deeper dive into the inner workings of Raft.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ZFS: A Primer</title>
      <link>http://localhost:1313/posts/07-zfs-primer/</link>
      <pubDate>Sun, 05 Jan 2025 21:20:26 -0500</pubDate>
      <guid>http://localhost:1313/posts/07-zfs-primer/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;Zettabit File System (ZFS) is a file system that is very popular in the Homelab community for it&amp;rsquo;s powerful capabilities as a file system and volume manager. It is designed to ensure data integrity and scalbility. While I am not an expert in ZFS, I hope to create guide here that outlines some of the fundamantal concepts of ZFS that I can return to over time.&lt;/p&gt;
&lt;p&gt;ZFS has a few key features that I will outline here:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dependency Injection In Go</title>
      <link>http://localhost:1313/posts/06-go-dependency-injection/</link>
      <pubDate>Sat, 07 Sep 2024 19:57:08 -0400</pubDate>
      <guid>http://localhost:1313/posts/06-go-dependency-injection/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;Dependency Injection (the &amp;lsquo;D&amp;rsquo; in SOLID design principles) is an important practice in good software architecture. When used well, it decouples a class&amp;rsquo;s dependency on a certain interface from any one particular implementation of that dependency. This means that any class which implements the common interface of the dependency can be injected into the class at runtime for easy configuration. This is especially helpful when it comes to creating stubs for mocking when writing unit tests.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Intro to K8s Autoscaling</title>
      <link>http://localhost:1313/posts/05-intro-to-k8s-autoscaling/</link>
      <pubDate>Fri, 06 Sep 2024 19:57:08 -0400</pubDate>
      <guid>http://localhost:1313/posts/05-intro-to-k8s-autoscaling/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;Autoscaling is a key technology that builds on the elasticity of distributed cloud computing. To understand autoscaling in the Kubernetes environment, it will be important to understand the basic enabling technologies: containerization and distributed computing. By leveraging hese two technologies, Kubernetes supports horizontal pod autoscaling (hpa) and cluster autoscaling. In this post I will dive into some brief background on Containerization and distributed computing (just enough to be dangerous) and then take a more focused look at the horizontal autoscaling functionality of Kubernetes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding CIDR Blocks and IPv4 Addressing</title>
      <link>http://localhost:1313/posts/04-understanding-ipv4-addressing/</link>
      <pubDate>Fri, 09 Aug 2024 20:01:16 -0400</pubDate>
      <guid>http://localhost:1313/posts/04-understanding-ipv4-addressing/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;The goal of this post will be to give an overview of IPv4 addresses. My aim is to do this incrementally by first covering the anatomy of an IPv4 address in its base 10 and binary representations. Second, I will look at CIDR block subnetting and subnet masks. Thirdly, I will append some helpful formulas for working with IP addresses.&lt;/p&gt;
&lt;h1 id=&#34;background--history&#34;&gt;Background &amp;amp; History&lt;/h1&gt;
&lt;p&gt;Before diving into the anatomy of IPv4 let&amp;rsquo;s turn back the page. In 1981, RFC 791 was published. This document outlined the &lt;em&gt;Internet Protocol&lt;/em&gt; and the IPv4 addressing scheme that would be used to uniquely identify and locate machines on the Internet.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Load Testing Applications with Locust</title>
      <link>http://localhost:1313/posts/03-locust-load-testing/</link>
      <pubDate>Mon, 22 Jul 2024 21:22:31 -0400</pubDate>
      <guid>http://localhost:1313/posts/03-locust-load-testing/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;I was recently tasked with configuring automated load tests to validate the health of a service under load and to identify bottlenecks and limits at which the service became overloaded. Up until this point, I had not worked first-hand with any load-testing frameworks. Although there are many great load testing tools out there like JMeter, K6s, and Locust, I decided to get started with Locust as it is a framework I had heard of before and is a pure Python framework (Python is the language I think in right now). To rewind, load testing frameworks allow engineers to programmatically produce stress on a system by simulating a large volume of incoming requests to that system. Requests can be, but are not limited to, HTTP calls. You can also load test with gRPC or IoT protocols like MQTT. Locust is an open-source Python-based load testing framework. With Locust, all user behaviour is defined in Python code and tests can be executed from a single machine or distributed across many machines.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Part 2: Building a Bare-metal Kubernetes Cluster on Raspberry Pis</title>
      <link>http://localhost:1313/posts/02-bare-metal-k3s-on-rpi-part-2/</link>
      <pubDate>Sun, 21 Jul 2024 20:30:55 -0400</pubDate>
      <guid>http://localhost:1313/posts/02-bare-metal-k3s-on-rpi-part-2/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;In part 1 of this post, I covered the basics of getting started building my Kubernetes cluster on Raspberry Pis. In particular, I laid out my goals and requirements, the build list, the network topology and setup, and the installation of K3s on each of the nodes. I recommend going back and checking out that post first if you haven&amp;rsquo;t already (&lt;a href=&#34;https://blog.fallow.app/posts/02-bare-metal-k3s-on-rpi-part-1/&#34;&gt;Part 1: Building a Bare-metal Kubernetes Cluster on Raspberry Pis&lt;/a&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Part 1: Building a Bare-metal Kubernetes Cluster on Raspberry Pis</title>
      <link>http://localhost:1313/posts/02-bare-metal-k3s-on-rpi-part-1/</link>
      <pubDate>Wed, 10 Jul 2024 20:29:01 -0400</pubDate>
      <guid>http://localhost:1313/posts/02-bare-metal-k3s-on-rpi-part-1/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;images/cluster.png&#34; alt=&#34;cluster&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;From the start of my career, I have been fascinated by Kubernetes. I love distributed systems and the rich history of how we have arrived where we are today with distributed computing. We live in the ongoing evolution of our communal vision for cloud computing. In the early years, the vision was to present a homogenous Unix-like interface for managing an underlying collection of servers such as BOINC. Now, we live in the world of many small virtualized unix environments distributed across servers and sharing compute.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Getting Started with Hugo &amp; GitHub Pages</title>
      <link>http://localhost:1313/posts/01-getting-started-w-hugo/</link>
      <pubDate>Fri, 05 Jul 2024 17:54:14 -0400</pubDate>
      <guid>http://localhost:1313/posts/01-getting-started-w-hugo/</guid>
      <description>&lt;h1 id=&#34;big-idea&#34;&gt;Big Idea&lt;/h1&gt;
&lt;p&gt;The goal of this post is to capture the steps required to get started with Hugo and GitHub Pages. Hugo is a Go-based static site generation tool. GitHub Pages is a feature of GitHub that allows anyone with a GitHub account to host a static site.&lt;/p&gt;
&lt;h1 id=&#34;part-1-setting-up-github-pages&#34;&gt;Part 1: Setting up GitHub Pages&lt;/h1&gt;
&lt;p&gt;In order to serve your site, you will need somewhere to host it. GitHub offers a free service called GitHub Pages that we will use for this purpose. GitHub Pages offers the free hosting of static website content. This means we will be able to build our Hugo site into a static site and then serve that via
GitHub Pages.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
